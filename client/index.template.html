<!doctype html>
<html lang='en'>
<head>
  <meta charset="utf-8" />
  <title>Bomb Attack</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <link rel='stylesheet' href='css/base.css'/>

  <script src='lib/phase-slide.js'></script>
  <script src='lib/phaser.min.js'></script>
  <script src='/socket.io/socket.io.js'></script>

  <!-- Google Identity Services is loaded dynamically after /api/config -->

  <script>
    // Socket.IO
    window.clientSocket = io.connect();

    // Minimal auth overlay (no webpack build needed)
    async function initAuthOverlay() {
      const el = document.getElementById('auth-overlay');
      const statusEl = document.getElementById('auth-status');
      const nameEl = document.getElementById('auth-name');
      const saveBtn = document.getElementById('auth-save-name');
      const logoutBtn = document.getElementById('auth-logout');
      const gBtn = document.getElementById('google-btn');
      const toggleBtn = document.getElementById('auth-toggle');
      const audioBtn = document.getElementById('audio-toggle');

      const characterSel = document.getElementById('avatar-character');
      const hairSel = document.getElementById('avatar-hair');
      const outfitSel = document.getElementById('avatar-outfit');
      const hatSel = document.getElementById('avatar-hat');
      const faceSel = document.getElementById('avatar-face');
      const patternSel = document.getElementById('avatar-pattern');
      const avatarSaveBtn = document.getElementById('avatar-save');
      const previewEl = document.getElementById('avatar-preview');

      // Audio mute toggle (persist in localStorage)
      function applyMuteState() {
        const muted = localStorage.getItem('uk01_muted') === '1';
        audioBtn.textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š';
        try {
          const g = window.__phaserGame;
          if (g && g.sound) g.sound.mute = muted;
        } catch (_) {}
      }

      audioBtn.addEventListener('click', () => {
        const muted = localStorage.getItem('uk01_muted') === '1';
        localStorage.setItem('uk01_muted', muted ? '0' : '1');
        applyMuteState();
      });

      // Keep applying in case Phaser game initializes later
      applyMuteState();
      setInterval(applyMuteState, 1500);

      toggleBtn.addEventListener('click', () => {
        el.classList.toggle('minimized');
      });

      async function refreshMe() {
        const r = await fetch('/api/me');
        const data = await r.json();
        if (data && data.user) {
          window.currentUser = data.user;
          statusEl.textContent = `å·²ç™»å…¥ï¼š${data.user.displayName}`;
          // auto-minimize after login to avoid blocking gameplay
          el.classList.add('minimized');
          nameEl.value = data.user.displayName || '';
          logoutBtn.style.display = 'inline-block';
          saveBtn.style.display = 'inline-block';
          avatarSaveBtn.style.display = 'inline-block';

          const parts = (data.user.avatarParts) || {};
          if (characterSel) characterSel.value = parts.character || '';
          hairSel.value = parts.hair || '';
          outfitSel.value = parts.outfit || '';
          hatSel.value = parts.hat || '';
          if (faceSel) faceSel.value = parts.face || '';
          if (patternSel) patternSel.value = parts.pattern || '';
          try { updatePreview(); } catch (_) {}
        } else {
          window.currentUser = null;
          statusEl.textContent = 'æœªç™»å…¥ï¼ˆå¯åŒ¿åéŠç©ï¼‰';
          logoutBtn.style.display = 'none';
          saveBtn.style.display = 'none';
          avatarSaveBtn.style.display = 'none';
        }
      }

      saveBtn.addEventListener('click', async () => {
        const displayName = (nameEl.value || '').trim();
        const r = await fetch('/api/profile', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ displayName })
        });
        const data = await r.json();
        if (!r.ok) {
          alert(data.message || data.error || 'æ›´æ–°å¤±æ•—');
          return;
        }
        await refreshMe();
      });

      function updatePreview(){
        if (!previewEl) return;
        const character = (characterSel && characterSel.value) ? characterSel.value : '';
        const hair = hairSel.value || '';
        const outfit = outfitSel.value || '';
        const hat = hatSel.value || '';
        const face = (faceSel && faceSel.value) ? faceSel.value : '';
        const pattern = (patternSel && patternSel.value) ? patternSel.value : '';
        const setBg = (cls, key) => {
          const el = previewEl.querySelector(cls);
          if (!el) return;
          if (!key) { el.style.backgroundImage = 'none'; return; }
          // Served from /images/game/cosmetics/*.png
          el.style.backgroundImage = `url(/images/game/cosmetics/${key}.png?v=20260206_14)`;
        };

        const charToFile = {
          'char_1': 'characters/char_1_pink_happy.png',
          'char_2': 'characters/char_2_pink_cry.png',
          'char_3': 'characters/char_3_yellow_happy.png',
          'char_4': 'characters/char_4_yellow_cry.png',
          'char_5': 'characters/char_5_blue_happy.png',
          'char_6': 'characters/char_6_blue_cry.png',
          'char_7': 'characters/char_7_mint_happy.png',
          'char_8': 'characters/char_8_mint_cry.png',
        };
        // base character preview
        const baseLayer = previewEl.querySelector('.av-base');
        if (baseLayer) {
          if (!character || character === '') {
            baseLayer.style.backgroundImage = 'url(/images/game/cosmetics/base.png?v=20260206_14)';
          } else {
            const f = charToFile[character];
            if (f) baseLayer.style.backgroundImage = `url(/images/game/cosmetics/${f}?v=20260206_14)`;
          }
        }

        // legacy layers no-op (hidden UI)
      }

      if (characterSel) characterSel.addEventListener('change', updatePreview);
      hairSel.addEventListener('change', updatePreview);
      outfitSel.addEventListener('change', updatePreview);
      hatSel.addEventListener('change', updatePreview);
      if (faceSel) faceSel.addEventListener('change', updatePreview);
      if (patternSel) patternSel.addEventListener('change', updatePreview);

      avatarSaveBtn.addEventListener('click', async () => {
        const displayName = (nameEl.value || '').trim();
        const avatarParts = {
          character: (characterSel ? (characterSel.value || '') : ''),
        };

        const r = await fetch('/api/profile', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ displayName: displayName || 'Player', avatarParts })
        });
        const data = await r.json();
        if (!r.ok) {
          alert(data.message || data.error || 'æ›´æ–°å¤±æ•—');
          return;
        }
        await refreshMe();
        // reload to ensure cosmetics apply for this session
        location.reload();
      });

      logoutBtn.addEventListener('click', async () => {
        await fetch('/auth/logout', { method: 'POST' });
        await refreshMe();
        location.reload();
      });

      // load config then GIS
      const cfg = await (await fetch('/api/config')).json();
      if (!cfg.googleClientId) {
        gBtn.textContent = 'Google ç™»å…¥æœªè¨­å®šï¼ˆç¼º GOOGLE_CLIENT_IDï¼‰';
        gBtn.disabled = true;
        await refreshMe();
        return;
      }

      // Load Google script
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://accounts.google.com/gsi/client';
        s.async = true;
        s.defer = true;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });

      window.google.accounts.id.initialize({
        client_id: cfg.googleClientId,
        callback: async (resp) => {
          const r = await fetch('/auth/google', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ credential: resp.credential })
          });
          const data = await r.json();
          if (!r.ok) {
            alert(data.error || 'ç™»å…¥å¤±æ•—');
            return;
          }
          await refreshMe();
          // ensure socket reconnects with cookie
          window.clientSocket.disconnect();
          window.clientSocket.connect();
        }
      });

      // Render a real Google button inside #google-render
      const render = document.getElementById('google-render');
      window.google.accounts.id.renderButton(render, { theme: 'outline', size: 'medium' });
      gBtn.style.display = 'none';

      await refreshMe();
    }

    window.addEventListener('load', initAuthOverlay);
  </script>

  <!-- bundle script injected by webpack HtmlWebpackPlugin -->
</head>
<body>
  <div id='auth-overlay' class='minimized'>
    <div class='auth-row' style='margin-top:0'>
      <div id='auth-status' style='flex:1'>è¼‰å…¥ä¸­â€¦</div>
      <button id='audio-toggle' title='éœéŸ³/å–æ¶ˆéœéŸ³'>ğŸ”Š</button>
      <button id='auth-toggle' title='é¡¯ç¤º/æ”¶åˆ'>å¸³è™Ÿ</button>
    </div>

    <div id='auth-body'>
      <div class='auth-row'>
        <div id='google-render'></div>
        <button id='google-btn'>Google ç™»å…¥</button>
        <button id='auth-logout' style='display:none'>ç™»å‡º</button>
        <a href='/leaderboard' target='_blank' style='display:inline-block;color:#fff;text-decoration:underline'>æ’è¡Œæ¦œ</a>
      </div>
      <div class='auth-row'>
        <input id='auth-name' placeholder='è‡ªè¨‚åç¨± (1..24)' maxlength='24' />
        <button id='auth-save-name' style='display:none'>å„²å­˜åç¨±</button>
      </div>

      <div class='auth-row'>
        <div id='avatar-preview' class='avatar-preview' title='é è¦½ï¼ˆç¤ºæ„ï¼‰'>
          <div class='av-layer av-base' style="background-image:url(/images/game/cosmetics/base.png?v=20260206_14)"></div>
        </div>

        <select id='avatar-character'>
          <option value=''>è§’è‰²ï¼šé è¨­</option>
          <option value='char_1'>ç²‰å…”ï¼ˆé–‹å¿ƒï¼‰</option>
          <option value='char_2'>ç²‰å…”ï¼ˆå“­å“­ï¼‰</option>
          <option value='char_3'>é»ƒå…”ï¼ˆé–‹å¿ƒï¼‰</option>
          <option value='char_4'>é»ƒå…”ï¼ˆå“­å“­ï¼‰</option>
          <option value='char_5'>è—å…”ï¼ˆé–‹å¿ƒï¼‰</option>
          <option value='char_6'>è—å…”ï¼ˆå“­å“­ï¼‰</option>
          <option value='char_7'>è–„è·å…”ï¼ˆé–‹å¿ƒï¼‰</option>
          <option value='char_8'>è–„è·å…”ï¼ˆå“­å“­ï¼‰</option>
        </select>

        <!-- legacy paper-doll selects (hidden) -->
        <select id='avatar-hair' style='display:none'></select>
        <select id='avatar-outfit' style='display:none'></select>
        <select id='avatar-hat' style='display:none'></select>
        <select id='avatar-face' style='display:none'></select>
        <select id='avatar-pattern' style='display:none'></select>

        <button id='avatar-save' style='display:none'>å„²å­˜è§’è‰²</button>
      </div>
    </div>
  </div>

  <div id='menu-overlay' class='menu-overlay hidden'>
    <div class='menu-panel'>
      <div class='menu-title'>Main Menu</div>
      <button id='btn-new-game' class='menu-btn'>New Game</button>
      <div class='menu-row'>
        <a class='menu-btn secondary' href='/leaderboard' target='_blank' style='display:block;text-align:center;line-height:1.2;text-decoration:none'>Leaderboard</a>
      </div>

      <div id='map-picker' class='hidden'>
        <div class='menu-title'>Select Map</div>
        <div class='menu-row'>
          <div class='menu-subtitle'>Mode</div>
          <div class='inline-controls'>
            <button class='chip mode active' data-mode='classic'>Classic</button>
            <button class='chip mode' data-mode='horde'>Horde</button>
          </div>
        </div>
        <div class='map-grid'>
          <button class='map-btn' data-map='hot_map'>Hot</button>
          <button class='map-btn' data-map='cold_map'>Cold</button>
          <button class='map-btn' data-map='arena_map'>Arena</button>
          <button class='map-btn' data-map='open_map'>Open</button>
          <button class='map-btn' data-map='rune_lab'>Rune Lab</button>
          <button class='map-btn' data-map='mirror_temple'>Mirror</button>
          <button class='map-btn' data-map='trap_garden'>Trap</button>
        </div>
        <div class='menu-row'>
          <button id='btn-map-back' class='menu-btn secondary'>Back</button>
        </div>
      </div>
    </div>
  </div>

  <div id='pending-overlay' class='menu-overlay hidden'>
    <div class='menu-panel'>
      <div id='pending-title' class='menu-title'>Pending Game</div>

      <div class='menu-row'>
        <div class='menu-subtitle'>Mode</div>
        <div id='pending-mode' class='chip label'>Classic</div>
      </div>

      <div id='ai-row-count' class='menu-row'>
        <div class='menu-subtitle'>AI æ•¸é‡</div>
        <div class='inline-controls'>
          <button id='ai-minus' class='chip'>-</button>
          <div id='ai-count' class='chip label'>3</div>
          <button id='ai-plus' class='chip'>+</button>
        </div>
      </div>

      <div id='ai-row-diff' class='menu-row'>
        <div class='menu-subtitle'>AI é›£åº¦</div>
        <div class='inline-controls'>
          <button class='chip diff' data-diff='easy'>Easy</button>
          <button class='chip diff active' data-diff='normal'>Normal</button>
          <button class='chip diff' data-diff='hard'>Hard</button>
        </div>
      </div>

      <div class='menu-row'>
        <button id='btn-start-game' class='menu-btn'>Start Game</button>
      </div>
      <div class='menu-row'>
        <button id='btn-leave-game' class='menu-btn secondary'>Leave</button>
      </div>
    </div>
  </div>

  <div id='game-wrapper'>
    <div id='game-container'></div>
  </div>

  <!-- Loading overlay (shown until Phaser preload completes) -->
  <div id='loading-overlay' class='loading-overlay'>
    <div class='loading-panel'>
      <div class='loading-title'>Loadingâ€¦</div>
      <div id='loading-sub' class='loading-sub'>è³‡æºè¼‰å…¥ä¸­</div>
      <div class='loading-bar'><div id='loading-bar-inner' class='loading-bar-inner'></div></div>
    </div>
  </div>

  <!-- Touch controls overlay (HTML; works even when canvas is letterboxed) -->
  <div id='touch-overlay' class='touch-overlay hidden'>
    <div id='touch-debug' class='touch-debug hidden'></div>
    <div id='touch-joy' class='touch-joy'>
      <div class='touch-joy-knob'></div>
    </div>
    <button id='touch-bomb' class='touch-bomb'>ğŸ’£</button>
  </div>

  <script>
    // HTML Menu overlay controller (more reliable on mobile than Phaser buttons)
    (function(){
      const menu = document.getElementById('menu-overlay');
      const mapPicker = document.getElementById('map-picker');
      const btnNew = document.getElementById('btn-new-game');
      const btnBack = document.getElementById('btn-map-back');

      function showMenu() {
        menu.classList.remove('hidden');
        mapPicker.classList.add('hidden');
        btnNew.style.display = 'block';
      }
      function showMaps() {
        mapPicker.classList.remove('hidden');
        btnNew.style.display = 'none';
      }
      function hideMenu() {
        menu.classList.add('hidden');
      }

      // Expose so Phaser states can toggle
      window.UK01Menu = { showMenu, showMaps, hideMenu };

      // Loading overlay helpers
      const loading = document.getElementById('loading-overlay');
      const loadingSub = document.getElementById('loading-sub');
      const loadingBar = document.getElementById('loading-bar-inner');
      window.UK01Loading = {
        set: (pct, text) => {
          try {
            if (typeof pct === 'number') loadingBar.style.width = Math.max(0, Math.min(100, pct)) + '%';
            if (text) loadingSub.textContent = text;
          } catch (_) {}
        },
        done: () => {
          try { loading.classList.add('hidden'); } catch (_) {}
        }
      };

      btnNew.addEventListener('click', () => {
        showMaps();
      });

      btnBack.addEventListener('click', () => {
        showMenu();
      });

      // Mode selection (Classic/Horde)
      let selectedMode = 'classic';
      function setMode(m) {
        selectedMode = (m === 'horde') ? 'horde' : 'classic';
        try {
          menu.querySelectorAll('.chip.mode').forEach(el => {
            el.classList.toggle('active', el.getAttribute('data-mode') === selectedMode);
          });
        } catch (_) {}
      }
      setMode('classic');

      // Handle mode chips
      menu.addEventListener('click', (e) => {
        const mbtn = e.target && e.target.closest && e.target.closest('.chip.mode');
        if (mbtn) {
          const m = mbtn.getAttribute('data-mode');
          setMode(m);
          return;
        }
      });

      // Map choose
      menu.addEventListener('click', (e) => {
        const b = e.target && e.target.closest && e.target.closest('.map-btn');
        if (!b) return;
        const map = b.getAttribute('data-map');
        if (!map) return;

        try {
          // mirror Phaser flow
          window.clientSocket.emit('leave lobby');
        } catch (_) {}

        window.clientSocket.emit('create game', { map_name: map, mode: selectedMode }, (payload) => {
          if (payload && payload.error) {
            alert(payload.message || payload.error);
            return;
          }
          const game_id = (payload && payload.game_id) ? payload.game_id : payload;
          hideMenu();
          // Start pending game state
          try {
            window.__phaserGame && window.__phaserGame.state && window.__phaserGame.state.start('PendingGame', true, false, game_id);
          } catch (_) {
            // fallback: reload
            location.reload();
          }
        });
      });

      // Do NOT auto-show menu before Phaser finishes preloading.
      // Menu will be shown by Phaser Menu state when ready.
      hideMenu();
    })();
  </script>

  <script>
    // Touch overlay controller
    (function(){
      const overlay = document.getElementById('touch-overlay');
      const joy = document.getElementById('touch-joy');
      const knob = joy.querySelector('.touch-joy-knob');
      const bomb = document.getElementById('touch-bomb');

      function getPlayer(){
        try {
          const g = window.__phaserGame;
          const st = g && g.state && g.state.getCurrentState && g.state.getCurrentState();
          if (st && st.player) return st.player;
        } catch(_) {}
        return null;
      }

      function setDir(dx, dy){
        const p = getPlayer();
        if (!p) return;
        p.touchLeft = p.touchRight = p.touchUp = p.touchDown = false;
        const dead = 14;
        if (Math.abs(dx) < dead && Math.abs(dy) < dead) return;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0) p.touchRight = true; else p.touchLeft = true;
        } else {
          if (dy > 0) p.touchDown = true; else p.touchUp = true;
        }
      }

      function resetDir(){
        const p = getPlayer();
        if (!p) return;
        p.touchLeft = p.touchRight = p.touchUp = p.touchDown = false;
      }

      // joystick touch handling
      let active = false;
      let startX=0, startY=0;
      const max = 52;

      function tryUnlockAudio(){
        try {
          const g = window.__phaserGame;
          if (g && g.sound && g.sound.context && g.sound.context.state === 'suspended') {
            g.sound.context.resume();
          }
          if (g && g.sound && g.sound.unlock) {
            g.sound.unlock();
          }
          // If BGM exists but didn't start (mobile autoplay lock), start it now.
          if (g && g._bgm && g._bgm.play && !g._bgm.isPlaying) {
            g._bgm.play();
          }
        } catch(_) {}
      }

      function onStart(e){
        tryUnlockAudio();
        active = true;
        const t = (e.touches && e.touches[0]) || e;
        startX = t.clientX; startY = t.clientY;
        e.preventDefault();
      }
      function onMove(e){
        if (!active) return;
        const t = (e.touches && e.touches[0]) || e;
        let dx = t.clientX - startX;
        let dy = t.clientY - startY;
        const len = Math.hypot(dx,dy) || 1;
        const clamp = Math.min(max, len);
        dx = (dx/len)*clamp;
        dy = (dy/len)*clamp;
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        setDir(dx, dy);
        e.preventDefault();
      }
      function onEnd(e){
        active = false;
        knob.style.transform = 'translate(0px, 0px)';
        resetDir();
        e && e.preventDefault && e.preventDefault();
      }

      joy.addEventListener('touchstart', onStart, {passive:false});
      joy.addEventListener('touchmove', onMove, {passive:false});
      joy.addEventListener('touchend', onEnd, {passive:false});
      joy.addEventListener('touchcancel', onEnd, {passive:false});

      // bomb button
      bomb.addEventListener('touchstart', (e)=>{
        const p=getPlayer(); if(p) p.touchBomb=true;
        e.preventDefault();
      }, {passive:false});
      const bombUp = (e)=>{ const p=getPlayer(); if(p) p.touchBomb=false; e && e.preventDefault && e.preventDefault(); };
      bomb.addEventListener('touchend', bombUp, {passive:false});
      bomb.addEventListener('touchcancel', bombUp, {passive:false});

      const dbg = document.getElementById('touch-debug');
      function show(){ overlay.classList.remove('hidden'); }
      function hide(){ overlay.classList.add('hidden'); bombUp(); onEnd(); }

      // debug (enable by adding ?debug=1)
      const params = new URLSearchParams(location.search);
      const debugOn = params.get('debug') === '1';

      // simple debug logger
      window.UK01Log = (msg) => {
        if (!debugOn) return;
        try {
          const line = (msg || '').toString().slice(0, 160);

          // show on screen
          dbg.classList.remove('hidden');
          dbg.textContent = line + "\n" + dbg.textContent;

          // also send to server logs (for cases where screenshots are blocked)
          try { window.clientSocket && window.clientSocket.emit && window.clientSocket.emit('client log', line); } catch (_) {}
        } catch (_) {}
      };

      if (debugOn) {
        dbg.classList.remove('hidden');
        setInterval(() => {
          const s = debugState();
          const line = `state=${s.state} socket=${(s.socket||'').slice(0,6)} user=${(s.user||'').slice(0,14)} player=${(s.player||'').slice(0,6)} dir=${s.tl?'L':''}${s.tr?'R':''}${s.tu?'U':''}${s.td?'D':''} bomb=${s.tb?'1':'0'}`;
          dbg.textContent = line + "\n" + dbg.textContent.split('\n').slice(1, 6).join('\n');
        }, 250);
      }

      function debugState(){
        try {
          const g = window.__phaserGame;
          const st = g && g.state && g.state.getCurrentState && g.state.getCurrentState();
          const p = st && st.player;
          const info = {
            state: st && st.key,
            socket: (window.clientSocket && window.clientSocket.id) || null,
            user: (window.currentUser && window.currentUser.id) || null,
            player: p && p.id,
            tl: p && !!p.touchLeft,
            tr: p && !!p.touchRight,
            tu: p && !!p.touchUp,
            td: p && !!p.touchDown,
            tb: p && !!p.touchBomb,
          };
          return info;
        } catch(_) { return {}; }
      }

      window.UK01Touch = { show, hide, debugState };
    })();
  </script>

  <script>
    // Pending Game overlay controller (AI count/difficulty + start)
    (function(){
      const pending = document.getElementById('pending-overlay');
      const titleEl = document.getElementById('pending-title');
      const modeEl = document.getElementById('pending-mode');
      const aiRowCount = document.getElementById('ai-row-count');
      const aiRowDiff = document.getElementById('ai-row-diff');
      const aiCountEl = document.getElementById('ai-count');
      const btnMinus = document.getElementById('ai-minus');
      const btnPlus = document.getElementById('ai-plus');
      const btnStart = document.getElementById('btn-start-game');
      const btnLeave = document.getElementById('btn-leave-game');

      let aiCount = 3;
      let aiDiff = 'normal';
      let joined = false;

      function show() {
        pending.classList.remove('hidden');
      }
      function hide() {
        pending.classList.add('hidden');
      }
      function setCount(n) {
        aiCount = Math.max(0, Math.min(3, n));
        aiCountEl.textContent = String(aiCount);
        try { window.clientSocket.emit('set ai count', { count: aiCount }); } catch(_){}
      }
      function setDiff(d) {
        aiDiff = d;
        // toggle UI
        pending.querySelectorAll('.chip.diff').forEach(el => {
          el.classList.toggle('active', el.getAttribute('data-diff') === aiDiff);
        });
        try { window.clientSocket.emit('set ai difficulty', { difficulty: aiDiff }); } catch(_){}
      }

      function updateFromGame(current_game) {
        if (!current_game) return;
        joined = true;
        if (current_game.name) titleEl.textContent = current_game.name;

        // show mode + toggle AI controls
        const mode = (current_game.mode === 'horde') ? 'Horde' : 'Classic';
        if (modeEl) modeEl.textContent = mode;

        const isHorde = (current_game.mode === 'horde');
        if (aiRowCount) aiRowCount.style.display = isHorde ? 'none' : '';
        if (aiRowDiff) aiRowDiff.style.display = isHorde ? 'none' : '';

        // enable start when at least 1 player
        const players = current_game.players ? Object.keys(current_game.players).length : 0;
        btnStart.disabled = !(players >= 1);
        btnStart.style.opacity = btnStart.disabled ? '0.55' : '1';
      }

      btnMinus.addEventListener('click', () => setCount(aiCount - 1));
      btnPlus.addEventListener('click', () => setCount(aiCount + 1));

      pending.addEventListener('click', (e) => {
        const b = e.target && e.target.closest && e.target.closest('.chip.diff');
        if (!b) return;
        const d = b.getAttribute('data-diff');
        if (d) setDiff(d);
      });

      // Default: disabled until we receive at least one 'update game'
      btnStart.disabled = true;
      btnStart.style.opacity = '0.55';

      let startInProgress = false;
      let startRetryTimer = null;

      function stopStartRetries() {
        if (startRetryTimer) {
          clearInterval(startRetryTimer);
          startRetryTimer = null;
        }
        startInProgress = false;
        btnStart.textContent = 'Start Game';
      }

      // If server launches game, hide overlay and stop retries
      try {
        window.clientSocket.on('launch game', () => {
          stopStartRetries();
          hide();
        });
      } catch (_) {}

      btnStart.addEventListener('click', () => {
        if (!joined) {
          alert('æ­£åœ¨åŒæ­¥æˆ¿é–“ç‹€æ…‹ï¼Œè«‹ç­‰ 1 ç§’å†æŒ‰ Start');
          return;
        }
        if (startInProgress) return;

        startInProgress = true;
        btnStart.textContent = 'Startingâ€¦';

        let tries = 0;
        const send = () => {
          tries += 1;
          try { window.clientSocket.emit('start game'); } catch(_){}
          if (tries >= 6) {
            // If still not launched, allow user to try again.
            stopStartRetries();
            alert('Start ä¼¼ä¹æ²’æœ‰æˆåŠŸï¼ˆå¯èƒ½ç¶²è·¯/åŒæ­¥å•é¡Œï¼‰ï¼Œè«‹å†æŒ‰ä¸€æ¬¡ Start');
          }
        };

        // Send immediately and retry a few times to avoid race conditions
        send();
        startRetryTimer = setInterval(send, 450);
      });

      btnLeave.addEventListener('click', () => {
        try { window.clientSocket.emit('leave pending game'); } catch(_){}
        hide();
        try { window.UK01Menu && window.UK01Menu.showMenu && window.UK01Menu.showMenu(); } catch(_){}
        try { window.__phaserGame && window.__phaserGame.state && window.__phaserGame.state.start('Menu'); } catch(_){}
      });

      // Expose
      window.UK01Pending = {
        show,
        hide,
        updateFromGame,
        setCount,
        setDiff,
      };

      // init UI
      setCount(aiCount);
      setDiff(aiDiff);
    })();
  </script>
</body>
</html>
